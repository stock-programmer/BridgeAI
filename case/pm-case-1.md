input:
我们需要做一个“用户实时积分排行榜”功能，在活动页展示前100名用户。希望能让用户看到排名的变化产生紧迫感，从而刺激他们去做更多任务，提升DAU和活跃度。

output:
【致开发团队：技术实现拆解】

- **核心技术挑战**：  
  实现高并发、低延迟的实时积分更新与Top 100排行榜动态刷新，同时保证数据一致性与展示公平性。

- **推荐技术方案**：  
  - **数据结构**：采用 Redis 的 **Sorted Set（ZSET）** 存储用户积分，以用户ID为member、积分为score，天然支持高效 Top N 查询（`ZREVRANGE`）和实时更新（`ZINCRBY`）。  
  - **更新机制**：任务完成事件通过消息队列（如 Kafka / RocketMQ）异步触发积分变更，避免直接写DB造成瓶颈；消费者服务负责更新 Redis ZSET 和持久化 DB（最终一致性）。  
  - **前端展示**：活动页每 3–5 秒轮询或通过 WebSocket 推送最新 Top 100 快照，减少无效请求。可考虑对“我的排名”单独推送（若用户在榜内），提升感知价值。  
  - **兜底策略**：Redis 故障时降级为定时（如每分钟）从 DB 聚合生成静态榜单，确保可用性。

- **数据链路**：  
  - **来源**：用户任务完成事件（来自业务服务）、历史积分（MySQL 用户积分表）。  
  - **处理**：事件驱动 → 消息队列 → 积分更新服务 → 同步更新 Redis ZSET + 异步写 MySQL。  
  - **存储**：  
    - 热数据：Redis（按活动维度分 Key，如 `rank:activity_2024_summer`）  
    - 冷数据/审计：MySQL（记录积分变动流水）

- **非功能性需求 (NFR)**：  
  - **性能**：榜单查询 P99 延迟 ≤ 200ms；支持峰值 QPS ≥ 1,000（预估 DAU 百万级活动）。  
  - **实时性**：用户完成任务后，榜单更新延迟 ≤ 2 秒。  
  - **一致性**：允许短暂不一致（最终一致），但禁止负积分或重复加分。  
  - **安全性**：防刷机制（如任务频控、设备/IP 限流）需在积分更新前校验。

- **预估工作量与风险**：  
  - **工作量**：L（中大型）  
    - 后端：积分事件接入 + 消息消费 + Redis 双写 + 接口开发 ≈ 5–7人日  
    - 前端：实时榜单组件 + 推送逻辑 ≈ 3人日  
    - 运维：Redis 容量评估 & 监控告警 ≈ 2人日  
  - **风险点**：  
    1. **热点 Key 问题**：Top 榜单集中读写可能打爆单个 Redis 分片 → 需提前做分片或本地缓存（如 Caffeine）缓解。  
    2. **积分超发**：任务回调重复或幂等未做好 → 必须加分布式锁或唯一任务ID去重。  
    3. **用户体验割裂**：若仅展示 Top 100，大量用户看不到自己排名 → 建议补充“我的排名”提示（即使不在前100，也显示“当前第 1,248 名”）。

> 💡 **建议产品确认**：是否需要支持“昨日榜”“周榜”？是否允许用户查看他人主页积分明细？这些将影响数据模型扩展性。